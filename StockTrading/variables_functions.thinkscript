# This is a testdriven view of the thinkscript tutorial from TD Ameritrade.  
# We will try to use assert and Labels to do test driven  thinking as we learn thinkscript. 
# https://tlc.thinkorswim.com/center/reference/thinkScript/tutorials 

## Introduction and Important parts. 

# ThinkScript is a proprietary language that is used to write code for the ThinkorSwim platform.  It is designed for analysis and is not a full bodied coding language like Python. It is a single threaded language. 

# Self-contained Scripts without references --In ThinkScript, each script or study is self-contained. If you have a custom function, it must be defined within the same script or study where it is used. This limitation requires that any functions you wish to use across multiple scripts must be copied and pasted into each script separately.  So, I will keep a master copy in the git repo Utilities/StockTrading.  

# Plot object -- The very first thing they show is the 'plot' object.  This is the primary way to display data on a chart.  It is a reserved word and cannot be used as a variable name.    

# Assert -  Assert false stops the script : https://tlc.thinkorswim.com/center/reference/thinkScript/Functions/Others/Assert  Throws a runtime error message in case the specified condition is false. 
## The error message can be viewed by clicking Exclamation indicator in the top left corner of the chart.
# If uncommented, this would stop this script
# Assert(no,"stop the script here. ");

#### Double.NaN is like null in Java

#In ThinkScript, `Double.NaN` stands for "Not a Number." It is a special floating-point value used to represent an undefined or unrepresentable value. When you assign `Double.NaN` to a variable or use it in a calculation, it essentially means that the variable does not hold a valid number.

#Here's what `Double.NaN` does in different contexts within a ThinkScript:
#Assert(Double.NaN, "This is a NaN value"); # This will throw an error and stop the script
Assert(IsNaN(Double.NaN), "This is a NaN value"); # This will not throw an error

# 1. **Plotting**: If you assign `Double.NaN` to a plot, that particular data point will not be displayed on the chart. This is often used to selectively hide elements of a plotted series without affecting the rest of the series.
# Plot the SMA, but only if the close is above the threshold, otherwise hide the plot. 

# Find the total number of bars displayed on the chart
def totalBars = HighestAll(BarNumber());
# Summing up all the close values
def sumCloseVals= fold j = 0 to totalBars with t=0 do t + GetValue(close, j);
# Calculate the average
def averageClose = sumCloseVals / totalBars;

plot SMAPlot = if close > averageClose then Average(close,14) else Double.NaN;
def adjustedValue = 5 + SMAPlot;
SMAPlot.SetDefaultColor(Color.GREEN);




# 2. **Calculations**: If `Double.NaN` participates in a calculation, the result will also be `Double.NaN`. This can be used as a way to propagate an error state through a series of calculations.

# 3. **Conditional Checks**: When you use `Double.NaN` in a condition, the condition will be evaluated as `false`. This can be used to prevent certain parts of the script from executing when the data is not valid.

# 4. **Script Execution**: Assigning `Double.NaN` to a variable or returning it from a script does not halt the execution of the script. The script will continue to run, and `Double.NaN` will propagate through subsequent calculations unless handled by conditional logic.




##### CHAPTER 1 DEFININING VARIABLES. 

# plot means put something on the chart--unless it is used in a custom function; then it is a return type. 

# plot can be defined separately or on the same line
##plot <plot_name>=<expression>;
##or
##plot <plot_name>;
##<plot_name>=<expression>;

#ToS is designed for speed.  You cannot declare traditional arrays and you declare variables with def knowing the interpreter will figure out the type--dynamic typing instead of strict typing. 

# You can declare a variable of the set of values for a stock in Fundamentals: close, high, hl2,...vwap. 

# where it is plotted is based on then Declaration used (lower, upper, on_volume) see them. 

# boolean values are translated into integers 0 or 1 

# def condition1 = close > 700;
# def condition2 = close > 900;
# def res = condition1 + condition2; 
# In this script, variable res will have value of 2 for those bars with Close price in greater 900 and 1 for those closing in between 700 and 900, and 0 for the rest. This script is also a good example of using multiple variables: once you have declared a variable, you are free to use it further on.

#Variables can be declared recursively, so that they use their own values in further calculation. Let’s start with a basic example:

# def vol = vol[1] + volume; 
# This script calculates cumulative volume starting from the first bar on chart. The logic behind it is quite simple: before the calculation, thinkScript® assigns 0 to the variable (it actually always does so), thus, its value at the first bar will be equal to volume. Then, for the second bar, it takes previous value and adds current volume to it; accumulation of volume proceeds until the last bar on chart. You must have noticed square brackets next to vol in the script. These brackets have thinkScript® take a certain value from the previous bar;var

# You have access to this for each bar
# Open: This is the price at which a security first trades upon the opening of an exchange on a trading day.
# High: The highest price at which a security trades during the course of the trading day.
# Low: The lowest price at which a security trades during the trading day.
# Close: The final price at which a security trades on a given trading day.
# Volume: This represents the total number of shares or contracts traded for a specific security or market during a given period.

##### CHAPTER 2.  FUNCTIONS.
script MyFunction {
    input data = close;
    input length = 12;
    def returnVal = GetValue(data, length);  
    # The name of the plot inside the script block does not have to match the name of the script. It can be named anything, but it must be a plot for the value to be accessible outside of the script block. 
    plot Result = returnVal;
}

# Usage
def myCustomValue = MyFunction(data = close, length = 10);


#### FOLD FUNCTION
fold
Syntax
def <result> = fold <index> = <start> to <end> [ with <variable> [ = <init> ] ] [ while <condition> ] do <expression>; 

Description
The fold operator allows you to perform iterated calculations. The list below explains the operator's logic (variable names are taken from the sample syntax above):

1. The purpose of the fold operator is to perform an iterated calculation and assign the final value to the result variable.

2. The index variable serves as a loop counter.

3. With each iteration, the index value increases by 1; the initial value of index is set by the start parameter.  

4. Iterated calculations will be performed while the index value is less than the end parameter. Once the index value becomes equal to the end parameter, the loop is terminated without calculation.

5. Within each iteration, the operator calculates the expression and assigns the result to the variable. In the expression, you are free to use the value of index and also reference the previous value of the variable. The initial value of the variable can be specified with the init parameter. If none is specified, then the variable is assigned a value of 0 before the first iteration.

6. The variable value is thus re-written after each iteration; after the last iteration, its final value is assigned to the result variable.

7. You can also add a condition within the while block of the operator. If this condition is violated, the result is assigned the last known value of variable and the loop is terminated.

Example 1
input n = 10;
plot factorial = fold index = 1 to n + 1 with p = 1 do p * index;
This example script calculates the factorial of a number.

Here, the factorial variable stores the result value of the calculation; index is the counter and its values are increased by 1 from 1 through n+1. The p is the variable whose value is re-written over iterations; its initial value is set to 1. The expression is the product of p and index. After the first iteration, p is 1*1=1. After the second iteration, it is equal to its current value (1) multiplied by current index (2), i.e., 2. After the third iteration, its current value (2) is multiplied by current index (3), yielding 6. Since the input n is set to 10, there will be 10 iterations (the loop is terminated when the index becomes equal to n+1=11), so the last value of p will be equal to 3,628,800 (a product of all numbers from 1 through 10). This is the value that is assigned to the factorial variable after the loop is complete.

Example 2
input price = close;
input length = 9;
plot SMA = (fold n = 0 to length with s do s + getValue(price, n, length - 1)) / length;
This example script calculates a simple moving average using fold.

Example 3
plot NextHigh = fold i = 0 to 100 with price = Double.NaN while IsNaN(price) do if getValue(high, -i, -99) > 40 then getValue(high, -i, -99) else Double.NaN;
This example script plots the closest high price value greater than 40 out of the next 100 bars.

# Define the number of bars to look back
def lookbackPeriod = 10;

# Define a threshold for the close price
def closePriceThreshold = 50; # Example threshold value

# Initialize a variable for the sum
def sumClose = 0;

# Loop over the last N bars
sumClose = fold i = 0 to lookbackPeriod - 1 with s do {
    # Get the close price i bars ago
    def thisClose = GetValue(close, i);
    
    # Check if thisClose is greater than the threshold
    if thisClose > closePriceThreshold {
        s + thisClose
    } else {
        Double.NaN; # Use NaN to indicate a failure in the condition, similar to an assertion failure
        break;
    }
};

# Plot or use the sum of close prices
plot SumClose = sumClose;
SumClose.SetDefaultColor(Color.CYAN);



The `fold` statement in ThinkScript is used for looping over a series of values, typically historical data points on a chart. The syntax of a `fold` statement can be broken down into several key components:

1. **Initialization of the Loop Variable**: This is where you set the starting value for the loop. The loop will iterate from this starting value up to, but not including, the ending value.

2. **Ending Condition**: This defines how many times the loop will iterate. It's the value at which the loop stops.

3. **Accumulator Variable**: This is a variable that accumulates or stores the result of each iteration of the loop.

4. **Loop Body**: Inside the loop, you define what happens during each iteration. This is where you manipulate or process your data.

Here's a basic structure of a `fold` loop in ThinkScript:

Syntax
def <result> = fold <index> = <start> to <end> [ with <variable> [ = <init> ] ] [ while <condition> ] do <expression>; 


```thinkscript
def accumulator = fold indexVariable = startValue to endValue - 1 with accumulatorVariable do {
    # Loop body: operations to perform in each iteration
};
```

- `def`: This keyword is used to define a new variable.
- `accumulator`: The name of the variable that will store the result of the loop.
- `fold`: This keyword initiates the fold loop.
- `indexVariable`: A temporary variable used to track the current iteration of the loop.
- `startValue`: The starting value of the loop (usually 0).
- `endValue`: The loop runs until the `indexVariable` reaches `endValue - 1`.
- `accumulatorVariable`: The initial value of the accumulator, which gets updated in each iteration.
- Inside the braces `{}` is the loop body, where you define the operations to be performed in each iteration.

For example, a `fold` loop that sums the close prices of the last 5 bars can be written as:

```thinkscript
def sumClose = fold i = 0 to 5 with s = 0 do s + getValue(close, i);
```

In this example:
- The loop starts with `i = 0` and iterates 5 times (`0 to 5`), effectively covering the last 5 bars.
- The accumulator `s` is initialized to `0`.
- In each iteration, the closing price from `i` bars ago is added to `s`.
- After the loop, `sumClose` holds the total sum of the last 5 closing prices.